В пространстве имен System . Th readi ng определен класс Ti mer, который позволяет
периодически вызывать методы из пула потоков. Создавая экземпляр этого
класса, вы как бы информируете пул, что вам нужен метод, обратный вызов
которого должен быть выполнен в заданное время. У класса Ti mer есть несколько очень похожих друг на друга конструкторов:
puЬl ic sea1ed c1ass Ti mer : Marsha1 ByRefObject . I Di sposaЫ e {
puЫ ic Timer( Ti merCa11back ca1 1 back . Object state.
I nt32 dueTi me. I nt32 period ) :
puЫ ic Ti mer(Ti merCa11back ca1 1 back . Object state .
Uint32 dueTi me. Uint32 period ) :
puЬl ic Ti mer(Ti merCa 1 1 back ca1 1 back . Object state.
I nt64 dueTi me. I nt64 period ) :
puЬl ic Ti mer( Ti merCa11back ca1 1 back . Object state.
Ti mespan dueTi me. Ti meSpan period ) :
Все эти конструкторы создают объект Ti mer. Параметр са1 1 back указывает
имя метода, обратный вызов которого должен выполниться потоком из пула.
Конечно, созданный метод обратного вызова должен соответствовать типу
делегата System . Threadi ng . Ti merCa 11 back, который определяется следующим образом:
de1 egate void Ti merCa 1 1 back ( Object state ) :
Параметр state конструктора служит для передачи методу обратного
вызова данных состояния или значения nu1 1, если эти данные отсутствуют.
Параметр dueTi me позволяет задать для CLR время ожидания (в миллисекундах) перед первым вызовом метода обратного вызова. Это время представляется 32-разрядным значением со знаком или без, 64-разрядным значением
со знаком или значением Ti meSpan. Для немедленной активизации метода обратного вызова следует присвоить параметру dueTi me значение О. Последний 
Периодические вычислительные операции 805
параметр period указывает периодичность (в миллисекундах) последующих
обращений к методу обратного вызова. Если ему передано значение Ti meout .
I nfi nite ( -1), поток из пула ограничится одним обращением к методу обратного вызова.
В пуле имеется всего один поток для всех объектов Ti mer. Именно он знает
время активизации следующего таймера. В этот момент поток пробуждается
и вызывает метод QueueUserWorkltem объекта ThreadPool, чтобы добавить в очередь
пула потоков запись, активизирующую метод обратного вызова. Если выполнение этого метода занимает много времени, возможно повторное срабатывание
таймера. В результате один метод будет выполняться несколькими потоками
пула. Решить эту проблему можно при помощи таймера, параметру period которого присвоено значение Ti meout . I nfi nite. Такой таймер срабатывает только
один раз. Затем в рамках метода обратного вызова вызывается метод Change
и указывается новое время задержки, а параметру peri od снова присваивается
значение Ti meout . I nfi nite. Вот как выглядят перегруженные версии метода
Change:
puЬl ic sealed cl ass Ti mer : Marshal ByRefObject . IDi sposaЫ e
puЬl ic Bool ean Change( Int32 dueTi me. I nt32 period ) ;
puЬl ic Bool ean Change(Ulnt32 dueTi me. U int32 period ) ;
puЬl ic Boolean Change ( I nt64 dueTi me. I nt64 period ) ;
puЫ ic Boolean Change(Ti meSpan dueTi me . Ti meSpan peri od ) ;
В классе Ti mer существует также метод Di spose, позволяющий вообще отключать таймер и при желании при помощи параметра noti fyObject сообщать
ядру о завершении всех ожидающих обратных вызовов. Вот как выглядят перегруженные версии метода Di spose:
puЫ ic seal ed cl ass Ti mer : Marshal ByRefObject . IDi sposaЫe
puЫ ic Boolean Di spose ( );
puЬl ic Bool ean Di spose( Wa itHandl e noti fyObject);
ВНИМАНИЕ
При утилизации объекта Timer сборщиком мусора поток пула останавливает
таймер, чтобы он больше не срабатывал . Поэтому при работе с таймером
следует проверять наличие переменной , поддерживающей его «На плаву»,
иначе обращения к методу обратного вызова прекратятся . Эта ситуация
подробно обсуждалась в главе 21 .
Следующий код демонстрирует поток из пула, вызывающий метод, который
сначала выполняется немедленно, а затем через каждые две секунды.
i nternal static class Ti merDemo
pri vate stati c Ti mer s_timer ;
продолжеиие .Р 
806 Глава 26. Асинхронные вычислительные операции
puЬl ic static void Go() {
Consol e . Writeli ne( " Main thread : starti ng а timer" ):
usi ng ( s_ti mer = new Ti mer(ComputeBoundOp . 5. О. Ti meout . Infi nite ) )
Consol e.Writeli ne( " Main thread : Doi ng other work here ... " ) :
Thread . Sl еер ООООО ): 11 Имитация дру гой работы ( 10 секунд )
11 Отмена таймера методом Di spose
11 Сигнатура этого метода должна соответствовать
11 си г натуре делегата Ti merCa l l back
pri vate static void ComputeBoundOp( Object state)
11 Этот метод выполняется потоком из пула
Consol e.Writeli ne ( " In ComputeBoundOp : state={O } ". state ) ;
Thread . Sleep ( l000 ); / / Имитация дру гой работы (1 секунда )
11 Заставляем таймер снова вызвать метод через 2 секунды
s_ti mer . Change(2000 . Ti meout . Infi nite ) :
11 Когда метод воз вращает управление . поток
11 воз вращается в пул и ожидает следующего задания
Варианты таймеров
Библиотека FCL содержит различные таймеры, но большинство программистов
даже не знают, чем они отличаются друг от друга.
О Класс Timer из пространства имен System. Threading. Этот класс рассматривался в предыдущем разделе. Он лучше других подходит для выполнения повторяющихся фоновых заданий в потоке пула.
О Класс Timer из пространства имен System. Windows.Forms. Создание экземпляра этого класса указывает Windows на необходимость связать таймер
с вызывающим потоком (см. Win32-функцию SetТi mer). При срабатывании
таймера Windows добавляет в очередь сообщений потока сообщение таймера (WM_ТI MER). Поток должен выполнить прокачку сообщений (message
pump ), чтобы извлечь эти сообщения и передать их нужному методу обратного вызова. Обратите внимание, что вся работа осуществляется одним
потоком - устанавливает таймер тот же поток, который исполняет метод
обратного вызова. Это предотвращает параллельный вызов метода таймера
несколькими потоками.
О Класс DispatcherTimer из пространства имен System. Windows. Threading.
Этот класс является эквивалентом класса Ti mer из пространства имен System .
Wi ndows . Forms для приложений Silverlight и WPF. 
Как пул управляет потоками 807
О Класс Timer из пространства имен System. Timers. Этот класс является,
по сути, оболочкой для класса Timer из пространства имен System . Threadi ng.
Он заставляет CLR по срабатыванию таймера ставить события в очередь
пула потоков. Поскольку класс System . Ti mers . Ti mer является производным от
класса Component из пространства имен System . ComponentMode l, таймеры можно
размещать в конструкторе форм приложеноя Microsoft Visual Studio. Этот
класс появился в FCL в те времена, ко г да у Microsoft еще отсутствовала четкая концепция потоков и таймеров. Вообще говоря, его стоило бы удалить,
оставив его функции классу System . Threadi ng . Ti mer. Я никогда не работаю
с классом System . Т i mers . Т i mer и не советую этого вам. Исключением является
ситуация, когда таймер нужно поместить в конструктора форм.
Как пул управляет потоками
В этом разделе я хотел бы остановиться на том, каким образом пул управляет
рабочими потоками и потоками ввода-вывода. Глубоко погружаться в детали
мы не будем, так как внутренняя реализация этого процесса менялась при
переходе от одной версии CLR к другой и явно будет изменена в будущем.
Поэтому представим пул потоков в виде черного ящика. Этот ящик является
не лучшим вариантом для одиночных приложений, так как в его основе лежит
технология распределения потоков, ориентированная на работу с большим
количеством приложений. Для некоторых приложеной она работает лучше,
чем для других. Впрочем, на сегодняшний день она прекрасно справляется
со своими задачами, и я рекомендую отнестись к ней с доверием. Вряд ли вы
сможете самостоятельно написать пул потоков, который будет функционировать лучше, чем поставляемый в составе CLR. Так как с течением времени
внутренняя система управления потоками у пула меняется, многие приложеноя
начинают работать лучше.
Ограничение количества потоков в пуле
CLR позволяет указать максимально возможное количество потоков, создаваемых пулом. Однако возникает ощущение, что задавать верхний предел для пула
не стоит, потому что это может привести к зависанию или мертвому запиранию
(клинчу). Представьте очередь из 1 000 рабочих элементов, заблокированную
сигнальным событием элемента под номером 1 001. Если верхний предел для
количества потоков равен 1000, этот новый поток исполнен не будет, а значит,
вся тысяча потоков навсегда окажется заблокированной. Конечному пользователю останется только завершить работу приложения, потеряв несохраненные
данные. Разработчики обычно не накладывают искусственных ограничений на
доступные для приложеноя ресурсы. Скажем, запуская приложение, никто не 
808 Глава 26. Асинхронные вычислительные операции
оговаривает объем используемой им памяти или ширину полосы пропускания.
Хотя при этом считается нормальным по каким-то причинам ограничивать
максимальное количество потоков в пул е.
Из-за проблем потребителей, касающихся зависания и клинча, разработчики
CLR постоянно увеличивают заданное по умолчанию максимально возможное
количество потоков в пул е. В настоящее время предел составляет 1 000 потоков, что для 32-разрядного процесса, имеющего не менее 2 Гбайт адресного
пространства, может рассматриваться как отсутствие ограничений. После загрузки библиотек Win32 и библиотек CLR, а также выделения собственной
и управляемой кучи, остается примерно 1 ,5 Г байт адресного пространства.
Так как каждый поток требует для стека в пользовательском режиме и блока
окружения (ТЕВ) более 1 Мбайт памяти, в 32-разрядном процессе допустимо
максимум 1 360 потоков. Попытки создать большее количество потоков приведут к исключению OutOfMemoryExcept i on. 64-разрядный процесс предлагает
8 Тбайт адресного пространства, так что теоретически вы можете создавать
сотни тысяч потоков. Но это будет пустая трата ресурсов, особенно с учетом
того факта, что идеальное количество потоков совпадает с количеством процессоров? По идее разработчикам CLR следует убрать ограничения, но в настоящий момент это невозможно, так как в результате прекратят свою работу
приложения, разработанные в предположении об ограниченном количестве
потоков в пул е.
Класс System . Threadi ng . ThreadPoo 1 предлагает несколько статических методов для управления количеством потоков в пуле: GetMaxThreads, SetMaxThreads,
GetMi nThreads, SetMi nThreads и GetAvai l aЬleThreads. Впрочем, я не рекомендую ими
пользоваться. Попытки менять заданные по умолчанию ограничения обычно
ухудшают работу приложений. Если вы считаете, что вашему приложению
требуются сотни или даже тысячи потоков, скорее всего, что-то не так с архитектурой приложения или механизмом использования потоков. О том, как
правильно применять потоки, мы поговорим в главе 27.
Управпение рабочими потоками
На рис. 26.1 показаны различные структуры данных, делающие рабочие потоки
частью пула. Метод ThreadPool . QueueUserWorkitem и класс Timer всегда помещают рабочие элементы в глобальную очередь. Рабочие потоки берут элементы
для обработки из очереди по алгоритму «первым пришел - первым ушел?.
А так как при наличии нескольких потоков элементы из глобальной очереди
могут удаляться одновременно, все рабочие потоки конкурируют за право на
запирание в рамках синхронизации потоков, которое гарантирует, что никакие два или более потока не смогут одновременно обрабатывать один и тот
же элемент. В некоторых приложениях это право на запирание становится
узким местом, до некоторой степени ограничивая масштабируемость и производительность. 
Как пул управляет потоками 809
Пул потоков в CLR
Local
Queue
1
Local
Queue
n
Рис. 26. 1 . Пул потоков в CLR
Рассмотрим процесс планирования заданий с помощью заданного по умолчанию планировщика (его можно получить через статическое свойство Default
класса TaskSchedul er)1• При планировании задания для нерабочего потока объект Task добавляется в глобальную очередь. При этом каждый рабочий поток
обладает собственной локальной очередью, в которую и добавляются планируемые задания.
Рабочий поток, готовый к обработке элементов, сначала проверяет наличие
объектов Task в локальной очереди. Обнаружив такой объект, он изымает его
из очереди и обрабатывает. Изъятие производится по алгоритму <<последним
пришел - первым ушел>>. Так как доступ к началу локальной очереди имеет
только рабочий поток, запирание в рамках синхронизации потоков больше
не требуется, а добавление заданий в очередь и изъятие их из нее происходят
очень быстро. Побочным эффектом такого поведения является то, что выполнение заданий идет с конца очереди.
ВНИМАНИЕ
Пул потоков не гарантирует определенного порядка обработки элементов
из очереди, особенно с учетом того факта, что наличие нескольких потоков делает возможной одновременную обработку нескол ьких элементов.
Поэтому крайне желательно, чтобы для приложения порядок обслуживания
элементов очереди не был принципиален.
Обнаружив пустую локальную очередь, рабочий поток пытается взять задание из локальной очереди другого рабочего потока. Задания, опять же, берутся
с конца очереди, а значит, требуется запирание в рамках синхронизации потоков, что несколько снижает производительность. Остается надеяться на то,
1 Поведение других объектов, производных от класса TaskScheduler, может отличаться от описываемого в данном разделе. 
81 0 Глава 26. Асинхронные вычислительные операции
что запирание будет случаться относительно редко. Если пустыми оказываются
все локальные очереди, рабочий поток извлекает (прибегая к запиранию) элемент из глобальной очереди по алгоритму «первым пришел - первым ушел?.
В случае пустой глобальной очереди рабочий поток переходит в режим ожидания. Если этот режим длится долго, поток просыпается и самоуничтожается,
освобождая занятые ресурсы (ядро, стеки, ТЕВ).
Пул быстро создает рабочие потоки, а их количество определяется значением, переданным в метод SetMi nThreads класса ThreadPool . Если вы не пользавались этим методом (а им и не стоит пользоваться), количество потоков по
умолчанию совпадает с количеством процессоров, которые может задействовать
процесс. Оно задается маской схожести процесса. Обычно дозволяется задействовать все процессоры\ и пул создает рабочие потоки, количество которых
быстро достигает числа процессоров. Затем пул начинает отслеживать частоту
завершения рабочих элементов, и для тех из них, выполнение которых занимает
много времени (с недокументированным значением), создает дополнительные
потоки. При увеличении темпа завершения элементов рабочие потоки уничтожаются.
Строки кэша и ложное разделение
Для повышения производительности повторяющихся доступов к памяти современные процессары оснащены встроенным кэшем. Доступ к кэшу - крайне
быстрая процедура, особенно если вспомнить, какой была скорость доступа процессара к памяти материнской платы. При первом обращении потока к памяти
процессор извлекает нужное значение и помещает его во встроенный кэш. Для
еще большего повышения производительности вся память логически делится
на строки кэша ( cache line ). Строка кэша для каждого из процессаров моего
компьютера состоит из 64 байт, то есть процессор извлекает из оперативной
памяти и сохраняет блоки именно такого размера2• Если приложению нужно
прочитать значение I nt32, извлекаются содержащие его 64 байт. Извлечение
большего количества байтов, чем требуется, обычно повышает производительность, так как большинство приложений для последующего доступа выбирает
данные, расположенные рядом с теми, доступ к которым осуществляется в текущий момент. Заранее помещая их в кэш процессора, мы избегаем доступа
к оперативной памяти.
Однако при доступе к байтам в одной строке кэша двух разных процессаров
не обойтись без взаимодействия между ядрами и эффективной передачи строки
1 В CLR версии 4 для 64-разрядного процесса чаще всего используются 64 процессора, а для
32-разрядного - 32.
2 Задать количество байтов в строке кэша можно при nомощи Win32-функции GetProcessorlnfonnation.
Моя библиотека Power Threading содержит управляемую оболочку этой функции, облегчая ее вызов
из управляемого кода. 
Строки кэша и ложное разделение 81 1
кэша из одного ядра в другое. Только в этом случае можно избежать одновременного изменения соседних байтов разными ядрами. В противном случае
производительность вычислительной операции может значительно снизиться.
Рассмотрим это на примере:
i nternal static class Fal seShari ng {
pri vate class Data {
11 Два соседних поля . скорее всего . расположены в одной строке кэша
puЬl ic I nt32 fiel d1:
puЫ ic I nt32 fiel d2:
pri vate const I nt32 i terati ons = 100000000 : // 100 миллионов
pri vate static I nt32 s_operati ons = 2:
pri vate static I nt64 s startTi me :
puЫ ic static void Mai n ( ) {
11 Выделяем объект и записываем начальное время
Data data = new Data ( ):
s_startTi me = Stopwatch .GetTi mestamp():
11 Два потока имеют доступ к своим полям внутри структуры
ThreadPool . QueueUserWorkitem (o => AccessData ( data . 0 ) ):
ThreadPool . QueueUserWork item (o => AccessData ( data . 1 ) ):
11 Для целей тестирования заблокируем поток Main
Console . Readli ne( ):
pri vate static void AccessData (Data data . I nt32 fiel d) {
11 Каждый поток имеет доступ к своим полям в объекте Data
for ( Int32 х = 0: х < i terati ons : х++ )
if (fiel d == 0) data . fi eld1++ : el se data . fi el d2++ :
11 Последний завершенный поток показывает время работы
if (Interlocked . Decrement( ref s_operati ons ) == 0)
Console . Writeli ne(
"Access time: { O : NO} " . Stopwatch .Getтi mestamp() - s_startтi me ) :
В этом коде объект Data обладает двумя полями, которые, скорее всего, находятся в одной строке кэша. Два потока пула исполняют метод AccessData.
Один поток добавляет к полю field1 единицу 1 00 000 000 раз. Второй поток
делает то же самое с полем fiel d2. Каждый поток, завершив работу, начинает
уменьшать на единицу значение в поле s _ Operat i ons. Поток, получивший в итоге
значение О, показывает, сколько времени заняло выполнение работы обоими
потоками. На своем компьютере я получил результат 15 856 074 мс. 
81 2 Глава 26. Асинхронные вычислительные операции
Теперь внесем изменения в класс Data:
[Structlayout( LayoutKi nd . Expl icit)J
pri vate cl ass Data {
11 Два поля больше не принадлежат одной строке кэша
[Fiel dOffset(O)J puЫ ic I nt32 fiel dl :
[Field0ffset( 64)J puЫ ic I nt32 fi eld2:
То есть я поместил поля в разные строки кэша (64 байта). После запуска
приложения я получил результат в 3 415 703 мс. То есть первая версия программы работала в четыре раза медленней из-за того, что процессору приходилось
передавать байты из одного потока в другой и обратно! С точки зрения программы два потока маиилу лиравали разными данными; а вот с точки зрения
строки кэша процессара это были одни и те же данные. Такая ситуация называется ложным. разделением. (false sharing). В процессарах с неравномерным
доступом к памяти (NUMA) возможно и более значительное снижение производительности. Во второй версии поля располагались в разных строках кэша,
что позволило процессору работать с ними независимо.
Думаю, вы уже убедились, насколько серьезно могут повлиять на производительность строки кэша и ложное разделение в случае одновременного
доступа разных потоков к близко расположенным данным. Распознав такую
ситуацию, вы найдете способ ее обойти (например, воспользовавшись атрибутом Fi eldOffset).
К примеру, следует помнить, что информация о размере массива располагается в начале соответствующей области памяти, рядом с информацией о нескольких первых элементах. Поэтому при доступе к любому элементу массива
CLR проверяет его индекс, обращаясь к информации о размере. А значит, чтобы
избежать дополнительного ложного разделения, следует запретить одному потоку запись в первые элементы массива, если в это время происходит доступ
других потоков к прочим элементам. 
Глава 27. Асинхронные
операции ввода-вывода
В предыдущей главе мы говорили об асинхронном выполнении вычислительных операций, когда пул потоков распределяет задания среди многочисленных
ядер, обеспечивая параллельное исполнение потоков, что позволяет повысить
производительность за счет более эффективного расходования ресурсов системы. В этой главе речь идет об асинхронном выполнении операций ввода-вывода,
когда аппаратное обеспечение решает свои задачи вообще без участия потоков
и процессора. Это, несомненно, оказывает влияние на эффективность расходования системных ресурсов, так как в этом случае эти ресурсы вообще не потребляются. Впрочем, пул потоков исполнения все равно играет важную роль, так как
именно там обрабатываются результаты разнообразных операций ввода-вывода.
Операции ввода-вывода в Windows
Для начала рассмотрим, как в Microsoft Windows выполняются синхронные
операции ввода-вывода. На рис. 27.1 показан компьютер с подсоединенным
.NЕТ
Пользовательский режим
в Win32
Режимядра
в Windows
Синхронный ввод-вывод в Windows
Сетъ DVD-ROM
[;]??
Рис. 27. 1. Синхронные операции ввода- вывода в Windows 
814 Глава 27. Асинхронные операции ввода- вывода
к нему периферийным оборудованием. Каждое из устройств снабжено собственной платой с микропроцессором специального назначения. К примеру,
плата жесткого диска умеет вращать диск, устанавливать головку на нужную
дорожку, читать данные с диска и записывать их на него, перемещать данные
в память компьютера и обратно.
Открытие дисковых файлов в программах происходит путем создания объекта Fi l eStream. Затем методом Read читаются данные из файла. Вызов метода
Read объекта Fi l eStream сопровождается переходом потока от управляемого
кода в машинный кодjкод пользовательского режима, при этом вызывается
Win32-функция ReadFi le (1). Она выделяет память для небольшой структуры,
называемой пакетом запросов ввода-вывода (1/0 Request Packet, IRP) (2). Эта
структура инициализирована дескриптором файла, смещением внутри файла,
с которого начнется чтение байтов, адресом массива Byte[], выделенного для
считываемых байтов, количеством байтов, предназначенных для передачи и т. п.
Функция ReadFi l е обращается к ядру Windows, переводя поток из кода
пользовательского режима в код в режиме ядра и передавая в ядро IRРструктуру (3). Из дескриптора ядро узнает, какое устройство предназначено
для конкретной операции ввода-вывода, после чего пакет запросов ставится
в I RР-очередь нужного драйвера устройства ( 4). Каждый драйвер устройства
управляет собственной очередью запросов ввода-вывода от всех запущенных
на машине процессов. При появлении IRР-пакетов драйвер устройства передает содержащуюся в них информацию соответствующему устройству, которое,
собственно, и выполняет операцию ввода-вывода (5).
Но важно помнить про следующее обстоятельство. В процессе выполнения
устройством операции ввода-вывода поток исполнения, передавший запрос,
не имеет никаких заданий, поэтому Windows переводит его в спящее состояние, чтобы не расходовать процессорное время впустую (6). Однако при этом
поток продолжает занимать место в памяти своим стеком пользовательского
режима, стеком режима ядра, блоком переменных окружения потока (Thread
Environment Block, ТЕВ) и другими структурами данных, к которым в этот
момент нет никакого доступа.
После завершения устройством операции ввода-вывода Windows пробуждает
поток, ставит его в очередь процессара и позволяет ему вернуться из режима ядра
сначала в пользовательский режим, а затем и в управляемый код (7, 8 и 9). Метод
Read объекта Fi l eStream при этом возвращает значение типа Int32, содержащее количество прочитанных из файла байтов. Это дает вам информацию о количестве
байтов, оказавшихся в массиве Byte[], ранее переданном методу Read.
Представим реализацию веб-приложения, в которой на каждый пришедший
на ваш сервер клиентский запрос следует сделать запрос к базе данных. При
клиентском запросе поток из пула потоков обращается к коду. При попытке синхронного запроса к базе данных этот поток окажется заблокированным на неопределенное время, необходимое для получения ответа из базы. Если в это время
придет еще один клиентский запрос, пул создаст еще один поток, который снова 
Операции ввода- вывода в Windows 815
окажется заблокированным. В итоге можно оказаться с целым набором блокированных потоков, ожидающих ответа из базы данных. То есть веб-сервер выделяет массу ресурсов (потоков и памяти для них), которые почти не используются!
Хуже всего то, что при получении результатов запросов из базы данных
блокировка с потоков будет снята одновременно и все они начнут исполняться.
В ситуации, когда количество потоков значительно превосходит количество
ядер процессора, операционная система прибегнет к частым переключениям
контекста, что значительно снизит производительность. Так что это не тот путь,
который позволил бы реализовать масштабируемое приложение.
Теперь рассмотрим процедуру выполнения асинхронных операций вводавывода в Windows (рис. 27.2). Здесь отсутствуют все внешние устройства,
кроме жесткого диска, кроме того, я добавил пул потоков среды CLR и слегка
отредактировал код. Открытие файла по-прежнему выполняется путем создания объекта Fi l eSt ream, но теперь ему передается флаг Fi l eOpt i ons . Asynchronous,
который указывает Windows, что операции чтения из файла и записи в файл
следует выполнять асинхронно.
.NET
Асинхронный ввод-вывод в Windows
F i l eSt ream fs = new F i l est ream ( ... , F i l eOption s . Asynch ronous) ;
f s . вeg i nRead ( ... , cal l ba c kMet hod , ... );
<D ф
CLR-nyл потоков
Отсюда nотоки мoryr
извлекать полные
IRР-пакеты
voi d cal l backмet hod ( . . . ) { . . . }
Здесь nоток не бло-
@
Рис. 27.2. Асинхронные операции ввода-вывода в Windows
Чтение данных из файла теперь выполняется методом Begi nRead, а не методом Read. Впрочем, этот метод тоже вызывает Win32-функцию ReadFi l е ( 1 ), которая выделяет место под IRР-пакет, инициализирует его, как и в предыдущем
сценарии (2), и передает в ядро Windows (3). Windows добавляет I RР-пакет 
81 6 Глава 27. Асинхронные операции ввода-вывода
в IRР-очередь драйвера жесткого диска ( 4), но на этот раз поток не блокируется, а немедленно возвращает управление после вызовов метода Begi nRead (5, 6
и 7). Теперь это может произойти еще до обработки IRР-пакета, поэтому у вас
не будет кода, который после вызова метода Begi nRead попытается получить
доступ к байтам в переданном методу массиве Byte[].
Может возникнуть вопрос, когда и каким образом обрабатываются считываемые данные? Методу Begi nRead в качестве аргумента передается имя метода
обратного вызова (в моем примере - Са 11 backMethod). Ссылающийся на метод
обратного вызова делегат внутри IRР-пакета фактически передается драйверу
устройства. Закончив обработку IRР-пакета (а), устройство помещает делегат
в очередь СLR-пула потоков (Ь). В дальнейшем какой-то из потоков пула берет
готовый IRР-пакет и активизирует метод обратного вызова (с)1• В результате
вы узнаете о завершении операции и внутри метода получите безопасный доступ к данным массива Byte[].
Теперь, разобравшись с основами, посмотрим на открывающиеся перед нами
перспективы. Предположим, в ответ на клиентский запрос сервер асинхронно
запрашивает базу данных. При этом наш поток не блокируется, а возвращается
в пул, получая возможность заняться обработкой других клиентских запросов.
Таким образом, получается, что для обработки всех входящих запросов достаточно всего одного потока. Полученный от базы данных ответ также окажется
в очереди пула потоков, то есть наш поток сможет тут же его обработать и отправить данные клиенту. Таким образом, единственный поток обрабатывает
не только клиентские запросы, но и все ответы базы данных. В итоге сервер
практически не потребляет системных ресурсов, но работает с максимально
возможной скоростью, так как переключения контекста не происходит!
Если элементы появляются в пуле быстрее, чем поток может их обработать,
пул может создать дополнительные потоки. Пул быстро создаст по одному потоку на каждый процессор. Соответственно, на машине с четырьмя процессарами четыре клиентских запроса к базе данных и ответа базы данных (в любой
комбинации) будут обрабатываться в четырех потоках без какого бы то ни было
переключения контекста2•
Однако при блокировке потока (выполнении синхронной операции вводавывода, вызове метода Thread . 51 еер или ожидании, связанном с запиранием
потока в рамках синхронизации потоков) Windows уведомляет пул о том, что
один из его потоков прекратил работу. Пул для восполнения недостаточной
загрузки процессара создает новый поток взамен заблокированного. К сажа-
' Готовые I RР-пакеты извлекаются из пула по алгоритму ?первым пришел - нервым обслужен?.
2 Предполагается, что другие потоки в это время отсутствуют. Большую часть времени действительно
так, ведь большинство компьютеров не задействует процессор на 100 %. Однако даже при полной
загрузке процессора все будет работать описанным образом, если исполняемые потоки имеют низкие приоритеты. Наличие других потоков приводит к переключениям контекста. Это плохо с точки
зрения производительности, но хорошо с точки зрения надежности. Напоминаю, что Windows выделяет на каждый процесс, по крайней мере, один поток и переключает контекст, гарантируя, что
даже блокировка о;щого потока не остановит работу приложения. 
Операции ввода-вывода в Windows 817
лению, такой выход из положения далек от идеального, потому что создание
нового потока является довольно дорогостоящей операцией с точки зрения
затрат времени и памяти.
Кроме того, позднее поток может быть разблокирован, и в итоге процессор
окажется перегруженным, что приведет к переключению контекста и снижению производительности. Впрочем, эта проблема решается средствами пула.
Завершившим свою работу потокам, которые вернулись в пул, не дают обрабатывать новые элементы, пока загрузка процессара не достигнет определенного
уровня. Таким способом уменьшается количество переключений контекста
и повышается производительность. Если впоследствии пул обнаружит, что потоков больше, чем необходимо, он просто позволит лишним потокам самоуничтожиться, освободив ресурсы.
Для реализации описанного поведения СLR-пул потоков использует такой
ресурс Windows, как порт завершения ввода-вывода ( 1/0 Completion Port).
Он создается при инициализации CLR. Затем с этим портом можно связать
подсоединяемые устройства, чтобы в результате их драйверы 4Знали? . куда
поставить в очередь IRР-пакет. Подробнее этот механизм описан в моей книге
4Windows via С/С++? (Microsoft Press, 2007).
Асинхронный ввод-вывод кроме минимального использования ресурсов
и уменьшения количества переключений контекста предоставляет и другие преимущества. Скажем, в начале сборки мусора CLR приостанавливает
все потоки в процессе. Получается, чем меньше у нас потоков, тем быстрее
произойдет сборка мусора. Кроме того, при сборке мусора CLR просматривает
в поисках корней все стеки потоков. Соответственно, чем меньше у нас потоков, тем меньше стеков приходится просматривать и тем быстрее работает
сборщик мусора. Плюс ко всему, если в процессе обработки потоки не были
заблокированы, большую часть времени они будут проводить в пуле в режиме
ожидания. А значит, в начале сборки мусора потоки окажутся наверху стека,
и поиск корней не займет много времени.
При достижении отлаживаемым приложеннем точки останова Windows
приостанавливает все его потоки. После возвращения к отладке следует возобновить все потоки, а значит, при наличии большого количества потоков
пошаговая отладка будет выполняться крайне медленно. Асинхронный вводвывод позволяет обойтись всего несколькими потоками, повышая тем самым
производительность отладки.
Выгоды этим не исчерпываются. Предположим, ваше приложение должно
загрузить с различных сайтов 10 изображений. Загрузка каждого из них занимает 5 секунд. В синхронном режиме выполнения (загрузка одного изображения за другим) вам потребуется 50 секунд. Однако при помощи всего
одного потока можно начать 10 асинхронных операций загрузки и получить
все изображения всего за 5 секунд! То есть время выполнения нескольких
синхронных операций ввода-вывода получается путем суммирования времени,
которое занимает каждая отдельная операция, в то время как в случае набора 
81 8 Глава 27. Асинхронные операции ввода-вывода
асинхронных операций ввода-вывода время их завершения определяется самой
медленной из выполняемых операций.
Приложепия с графическим интерфейсом благодаря асинхронным операциям
получают интерфейс, всегда реагирующий на действия конечного пользователя.
В приложениях Silverlight вообще все операции ввода-вывода выполняются
только асинхронно. В версии библиотеки FCL для Silverlight просто отсутствуют
методы выполнения синхронных операций. Это было сделано намеренно. Ведь
приложения Silverlight запускаются в браузерах, например в Windows Internet
Explorer, а потоки, обслуживающие синхронные операции, могут заблокировать ответ от веб-сервера. В результате браузер просто зависнет. Пользователь
не сможет даже перейти на соседнюю вкладку. Именно поэтому в Windows
Internet Explorer 8 для каждой вкладки создается свой процесс. И в итоге,
если одна вкладка перестает отвечать, это никак не сказывается на работе
остальных. К сожалению, такой подход требует большого количества ресурсов,
хотя и позволяет получить быстрореагирующий пользовательский интерфейс1•
Модель асинхронного
программирования в CLR
Асинхронные операции являются ключом к созданию высокопроизводительных, масштабируемых приложений, выполняющих множество операций при
помощи небольтого количества потоков. Вместе с пулом потоков они дают
возможность эффективно задействовать все процессары в системе. Осознавая
этот огромный потенциал, разработчики CLR разработали эталон программирования, призванный сделать его доступным для всех программистов. Этот
эталон был назван .моделью асинхрон.н.ого програ.м..м.ирован.ия (Asynchronous
Programming Model, АРМ).
Лично мне эта модель очень симпатична, потому что ее довольно легко
освоить, она проста в использовании и поддерживается многими типами библиотеки FCL. Вот несколько примеров.
1:1 Все производвые от System . IO. Stream классы, которые взаимодействуют
с аппаратными устройствами (в том числе Fi l eStream и NetworkStream), поддерживают методы Begi nRead и Begi nWri te. Эти методы поддерживаются
и классами, производными от Stream, которые не взаимодействуют с аппаратными устройствами (в том числе классами BufferedStream, MemoryStream
и CryptoStream). Однако код в этих методах выполняет лишь вычислительные
операции, а не операции ввода-вывода, поэтому для выполнения последних
требуется поток.
1:1 Класс System . Net . Dns поддерживает методы Begi nGetHostAddresses, Begi nGetHostByName, Begi nGetHostEntry и Begi nResol ve.
1 Собственная вкладка выделяется каждому процессу также из соображений безопасности. 
Модель асинхронного программирования в CLR 81 9
О Класс System . Net . Sockets . Socket поддерживает методы Begi nAccept, Begi nConnect,
Beg i nDi sconnect, Beg i nRecei v? Begi nRecei veFrom, Begi nRecei veMessageFrom,
Begi nSend, Begi nSendFi le и Begi nSendTo.
О Все классы, производные от System . Net . WebRequest (в том числе F i l eWebRequest,
FtpWebRequest и HttpWebRequest ), предлагают методы Begi nGetRequestStream
и Begi nGetResponse.
О Класс System . I О. Ports . Seri а l Port обладает предназначенным только для чтения свойством BaseStream, которое возвращает объект Stream, обладающий,
как вы знаете, методами Begi nRead и Begi nWri te.
О Класс System . Data . Sql Cl i ent . Sql Command поддерживает методы Begi nExecuteNonQuery, Begi nExecuteReader и Begi nExecuteXml Reader.
Кроме того, для всех типов делегатов определен метод Begi n lnvoke, который можно использовать в АРМ. Наконец, инструменты создания типовпредставителей (proxy) для веб-сервисов (такие как WSDL.exe и SvcUti l.exe)
также генерируют методы, пригодные для использования в рамках АРМ.
Названия этих методов начинаются с Begi n и у каждого из них есть парный
метод, название которого начинается с End. Как видите, поддержка АРМ буквально <<пронизывает? всю библиотеку FCL.
Для синхронного чтения байтов из объекта Fi l eStream вызывается его метод
Read с таким прототипом:
puЫ ic I nt32 Read(Byte[J array , I nt32 offset . I nt32 count)
Вызов функции, выполняющей синхронный ввод-вывод, приводит к непредсказуемому состоянию приложения, так как вы не знаете, когда метод
возвратит управление и возвратит ли его вообще. Представьте, к примеру, что
открываемый файл находится на сервере, но перед вызовом метода Read сервер
перестал работать из-за отключения электроэнергии.
Так что для написания работоспособного, надежного и масштабируемого
приложения следует пользоваться только методами, выполняющими асинхронный ввод-вывод. Например, методом Begi nRead объекта Fi l eStream:
IAsyncResult Begi nRead(Byte[J array , I nt32 offset . I nt32 numBytes .
AsyncCal l back userCa l l back . Object stateObject)
Обратите внимание, что первые три параметра методов Begi nRead и Read
идентичны. Более того, каждый метод Begi nXxx имеет те же самые параметры,
что и его парный синхронный метод. Однако, кроме того, в методах Begi nXxx
есть и пара дополнительных параметров: userCa ll back и stateObject. Первый
принадлежит типу делегата AsyncCa ll back:
puЬl ic del egate void AsyncCallback ( IAsyncResult ar) ;
Ему передается имя метода (или лямбда-выражение), который должен выполняться потоком пула после завершения асинхронного ввода-вывода. Второй
дополнительный параметр метода Begi nXxx - stateObject - ссылается на объ-
820 Глава 27. Асинхронные операции ввода-вывода
ект, который вы хотите передать методу обратного вызова. Доступ к objectState
внутри метода обратного вызова осуществляется через предназначенное только
для чтения свойство AsyncState интерфейса IAsyncResult.
Все методы Begi nXxx возвращают объект, реализующий интерфейс System .
IAsyncResult. Любой из этих методов конструирует объект, который уникальным образом идентифицирует ваш запрос ввода-вывода, ставит его в очередь
драйвера устройства и возвращает ссылку на объект IAsyncResult. Этот объект
можно представить как уведомление. Ссылку на него на самом деле можно
проигнорировать, потому что она сохраняется внутри CLR. После завершения
операции поток пула активизирует метод обратного вызова, которому автоматически передается ссылка на объект IAsyncResult.
Внутри вашего метода вызывается соответствующий метод EndX.x:x, в который передается объект IAsyncResult. Результат его работы аналогичен результату, который вы бы получили, вызвав синхронный метод. К примеру, метод Read
объекта Fi l eStream возвращает значение типа I nt32, указывающее количество
байтов, считанных из потока ввода-вывода. Метод EndRead объекта Fi l eStream
возвращает аналогичное значение:
I nt32 EndRead( IAsyncResult result ) ; 11 Количество байтов . считанных
11 из потока в вода- вывода
Вот как выглядит код серверного класса для именованного канала PipeServer,
реализованный при помощи АРМ:
i nternal sealed cl ass Pi peServer {
11 Каждый серверный объект выполняет в канале асинхронные операции
pri vate readonly NamedPi peServerStream m_pi pe = new NamedPipeServerStream(
" Echo " . PipeDi rection.InOut . -1. Pi peTransmi ssi onMode. Message.
Pi peOpt ions . Asynchronous 1 Pi peOpt ions . WriteThrough ):
puЬl ic PipeServer() {
11 Асинхронное принятие соединения с клиентом
m_pi pe . Begi nWaitForConnecti on(Cl ientConnected . null);
pri vate void Cl i entConnected( IAsyncResul t result) {
11 Клиент подсоединен . принимаем другого клиента
new PipeServer ( ); // Accept another cl i ent
11 Принятие соединения с клиентом
m_pi pe . EndWai tForConnection(result) ;
11 Асинхронное ч тение запроса со стороны клиента
Byte[J data = new Byte [lOOOJ ;
m_pi pe . Begi nRead( data . О. data . Length . GotRequest . data ); 
Модель асинхронного программирования в CLR 821
pri vate void GotRequest( IAsyncResult result)
11 Обработка приеланного клиентом запроса
I nt32 bytesRead = m_pi pe . EndRead ( result) ;
Byte[J data = ( Byte[] ) result . AsyncState;
11 Мой сервер просто меняет рег истр символов .
11 но вы можете вставить сюда любую выч ислительную операцию
data = Encodi ng . UTFB .GetBytes (
Encodi ng . UTFB .GetStri ng(data . О. bytesRead ) . ToUpper(). ToCharArray ( ));
11 Асинхронная отправ ка ответа клиенту
m_pi pe . Begi nWrite(data . О. data . Length . WriteDone . null);
pri vate void WriteDone ( IAsyncResul t result) {
11 Ответ клиенту отправлен . закрываем соединение со своей стороны
m_pipe . EndWrite( result ) ;
m_pipe.Cl ose( );
Экземпляр этого класса следует создать до соединения клиента с сервером,
так как это соединение обеспечивается вызовом метода Begi nWaitForConnecti on.
После его установки поток пула вызывает метод Cl i entConnect и создает новый
экземпляр класса Pi peServer, предоставляя возможность· соединения дополнительного клиента. Тем временем метод Cl i entConnected вызывает метод Begi nRead,
заставляя драйвер сетевого устройства дождаться входящих данных от клиента
и поместить их в указанный массив Byte[].
При отправке клиентом данных поток из пула вызывает метод GotRequest.
Этот метод получает доступ к массиву Byte[] (путем запроса свойства
AsyncState ), после чего обрабатывает данные. В моем примере преобразование
массива Byte[] к типу Stri ng осуществляется при помощи кодировщика UTF-8,
затем символы строки переводятся в верхний регистр, после чего строка преобразуется обратно в массив Byte[]. Вы же можете заменить этот код собственной
версией вычислительной операции, чтобы сервер выполнял ту работу, которая
реально требуется. Далее метод GotRequest вызывает метод Begi nWri te и отправляет полученный результат обратно клиенту. Когда драйвер устройства завершает отправку данных, поток пула вызывает метод Wri teDone, закрывающий
канал и обрывающий соединение.
Обратите внимание, что все методы следуют единому эталону. Они заканчиваются вызовом метода Begi nX.xx (исключая последний метод, WriteDone) и начинаются вызовом метода EndX.xx (исключая конструктор). Между методами
EndXXx и Begi nXxx выполняются только вычислительные операц